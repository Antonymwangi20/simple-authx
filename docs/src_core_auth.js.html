<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>src/core/auth.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-core_auth.AuthManager.html">AuthManager</a><ul class='methods'><li data-type='method'><a href="module-core_auth.AuthManager.html#generateTokens">generateTokens</a></li><li data-type='method'><a href="module-core_auth.AuthManager.html#login">login</a></li><li data-type='method'><a href="module-core_auth.AuthManager.html#loginWithIdentifier">loginWithIdentifier</a></li><li data-type='method'><a href="module-core_auth.AuthManager.html#refresh">refresh</a></li><li data-type='method'><a href="module-core_auth.AuthManager.html#register">register</a></li></ul></li><li><a href="module-core_auth-AuthManager.html">AuthManager</a></li><li><a href="module-security_audit.AuditLogger.html">AuditLogger</a></li><li><a href="module-security_audit-AuditLogger.html">AuditLogger</a></li><li><a href="module-security_security.SecurityManager.html">SecurityManager</a></li><li><a href="module-security_security-SecurityManager.html">SecurityManager</a></li></ul><h3>Modules</h3><ul><li><a href="module-core_auth.html">core/auth</a></li><li><a href="module-core_unified-api.html">core/unified-api</a><ul class='methods'><li data-type='method'><a href="module-core_unified-api.html#.createAuth">createAuth</a></li><li data-type='method'><a href="module-core_unified-api.html#~addMFARoutes">addMFARoutes</a></li><li data-type='method'><a href="module-core_unified-api.html#~addSessionRoutes">addSessionRoutes</a></li><li data-type='method'><a href="module-core_unified-api.html#~addSocialRoutes">addSocialRoutes</a></li><li data-type='method'><a href="module-core_unified-api.html#~createMemoryAdapter">createMemoryAdapter</a></li><li data-type='method'><a href="module-core_unified-api.html#~createProtectMiddleware">createProtectMiddleware</a></li><li data-type='method'><a href="module-core_unified-api.html#~createRouter">createRouter</a></li><li data-type='method'><a href="module-core_unified-api.html#~normalizeConfig">normalizeConfig</a></li><li data-type='method'><a href="module-core_unified-api.html#~setupAdapter">setupAdapter</a></li><li data-type='method'><a href="module-core_unified-api.html#~setupPlugins">setupPlugins</a></li></ul></li><li><a href="module-security_audit.html">security/audit</a></li><li><a href="module-security_security.html">security/security</a></li><li><a href="module-simple-authx.html">simple-authx</a></li></ul><h3>Global</h3><ul><li><a href="global.html#getAuth">getAuth</a></li><li><a href="global.html#getDefaultConfig">getDefaultConfig</a></li><li><a href="global.html#hasherName">hasherName</a></li><li><a href="global.html#initializeAuth">initializeAuth</a></li><li><a href="global.html#isAuthInitialized">isAuthInitialized</a></li><li><a href="global.html#protect">protect</a></li><li><a href="global.html#resetAuth">resetAuth</a></li><li><a href="global.html#verifyPassword">verifyPassword</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">src/core/auth.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// src/core/auth.js - Fixed AuthManager with backward compatibility

/**
 * @fileoverview Core authentication manager handling user registration, login, and token management
 * @module core/auth
 */

import jwt from 'jsonwebtoken';
import crypto from 'crypto';

/**
 * Core authentication manager class
 * Handles user registration, login, token generation, and verification
 *
 * @class AuthManager
 * @example
 * const authManager = new AuthManager({
 *   adapter: myAdapter,
 *   secret: 'my-secret',
 *   refreshSecret: 'my-refresh-secret',
 *   accessExpiry: '15m',
 *   refreshExpiry: '7d'
 * });
 */
export class AuthManager {
  /**
   * Creates a new AuthManager instance
   * @param {Object} options - Configuration object
   * @param {Object} options.adapter - Storage adapter (must implement findUser, createUser, verifyUser, etc.)
   * @param {string} options.secret - JWT access token secret
   * @param {string} options.refreshSecret - JWT refresh token secret
   * @param {string} [options.accessExpiry='15m'] - Access token expiration time
   * @param {string} [options.refreshExpiry='7d'] - Refresh token expiration time
   * @param {Object} [options.hooks] - Lifecycle hooks
   * @param {Object} [options.config] - User field configuration
   */
  constructor(options = {}) {
    this.secret = options.secret || process.env.JWT_SECRET || 'dev_secret';
    this.refreshSecret =
      options.refreshSecret || process.env.JWT_REFRESH_SECRET || 'dev_refresh_secret';
    this.accessExpiry = options.accessExpiry || '15m';
    this.refreshExpiry = options.refreshExpiry || '7d';
    this.adapter = options.adapter;
    this.config = options.config || {};

    // Hooks (can be set externally or imported)
    this.hooks = options.hooks || {};
  }

  /**
   * Generates access and refresh tokens for a user
   * @param {Object} payload - Token payload (typically contains userId)
   * @returns {{accessToken: string, refreshToken: string}} Token pair
   */
  generateTokens(payload) {
    const accessToken = jwt.sign(payload, this.secret, { expiresIn: this.accessExpiry });
    const jti =
      (crypto.randomUUID &amp;&amp; crypto.randomUUID()) || crypto.randomBytes(16).toString('hex');
    const refreshPayload = { ...payload, jti };
    const refreshToken = jwt.sign(refreshPayload, this.refreshSecret, {
      expiresIn: this.refreshExpiry,
    });
    return { accessToken, refreshToken };
  }

  /**
   * Registers a new user with flexible identifiers (username, email, or phoneNumber)
   * @param {string|Object} usernameOrData - Username string (legacy) or userData object (new)
   * @param {string} [usernameOrData.username] - Username
   * @param {string} [usernameOrData.email] - Email address
   * @param {string} [usernameOrData.phoneNumber] - Phone number
   * @param {string} usernameOrData.password - Password (required)
   * @param {string} [password] - Password (only used in legacy mode)
   * @returns {Promise&lt;Object>} Object containing user and tokens {user, accessToken, refreshToken}
   * @throws {Error} If required fields are missing or user already exists
   */
  async register(usernameOrData, password) {
    if (!this.adapter) throw new Error('No database adapter configured');

    let userData;

    // Backward compatibility: support both old and new signature
    if (typeof usernameOrData === 'string') {
      // Legacy format: register(username, password)
      console.log('[AuthManager] Using legacy register format (username, password)');
      userData = {
        username: usernameOrData,
        password,
      };
    } else if (typeof usernameOrData === 'object') {
      // New format: register({ username, password, email, ... })
      console.log('[AuthManager] Using new register format (userData object)');
      userData = usernameOrData;
    } else {
      throw new Error('Invalid registration data format');
    }

    // Extract password and other fields
    const { password: pwd, ...userFields } = userData;

    if (!pwd) {
      throw new Error('password is required');
    }

    console.log('[AuthManager] Registration data:', {
      username: userFields.username,
      email: userFields.email,
      phoneNumber: userFields.phoneNumber,
      hasPassword: !!pwd,
    });

    // Validate required fields
    const config = this.config?.userFields || {
      identifiers: ['username', 'email', 'phoneNumber'],
      required: [],
    };

    // Check that at least one identifier is provided
    const identifiers = config.identifiers || ['username', 'email', 'phoneNumber'];
    const hasIdentifier = identifiers.some((id) => userData[id]);

    if (!hasIdentifier) {
      throw new Error(`At least one identifier is required: ${identifiers.join(', ')}`);
    }

    // Validate explicitly required fields
    for (const field of config.required || []) {
      if (!userData[field]) {
        throw new Error(`${field} is required`);
      }
    }

    // Check if user already exists (by any identifier)
    for (const identifier of identifiers) {
      if (userData[identifier]) {
        const existing = await this.adapter.findUser(userData[identifier]);
        if (existing) {
          throw new Error(`User with this ${identifier} already exists`);
        }
      }
    }

    // Validate custom fields
    if (config.validate) {
      for (const [field, validator] of Object.entries(config.validate)) {
        if (userData[field] &amp;&amp; !validator(userData[field])) {
          throw new Error(`Invalid ${field} format`);
        }
      }
    }

    console.log('[AuthManager] Creating user...');
    const user = await this.adapter.createUser(userData);
    console.log('[AuthManager] User created:', user.id);

    const tokens = this.generateTokens({ userId: user.id });
    const decoded = jwt.decode(tokens.refreshToken);
    await this.adapter.storeRefreshToken(
      user.id,
      tokens.refreshToken,
      new Date(decoded.exp * 1000)
    );

    if (this.hooks.onRegister) await this.hooks.onRegister(user);

    return { user, ...tokens };
  }

  /**
   * Logs in a user with username and password (legacy method)
   * @param {string} username - Username
   * @param {string} password - Password
   * @returns {Promise&lt;Object>} Object containing user and tokens {user, accessToken, refreshToken}
   * @throws {Error} If credentials are invalid
   */
  async login(username, password) {
    console.log('[AuthManager] Using legacy login method');
    return this.loginWithIdentifier(username, password);
  }

  /**
   * Logs in a user with any identifier (username, email, or phoneNumber)
   * @param {string} identifier - Username, email, or phone number
   * @param {string} password - Password
   * @returns {Promise&lt;Object>} Object containing user and tokens {user, accessToken, refreshToken}
   * @throws {Error} If credentials are invalid
   */
  async loginWithIdentifier(identifier, password) {
    if (!this.adapter) throw new Error('No database adapter configured');

    console.log('[AuthManager] Login attempt for:', identifier);

    // Try to find and verify user with the identifier
    const user = await this.adapter.verifyUser(identifier, password);

    if (!user) {
      console.log('[AuthManager] Login failed: Invalid credentials');
      throw new Error('Invalid credentials');
    }

    console.log('[AuthManager] User verified:', user.id);

    const tokens = this.generateTokens({
      userId: user.id,
      email: user.email,
      username: user.username,
      phoneNumber: user.phoneNumber,
    });

    const decoded = jwt.decode(tokens.refreshToken);
    await this.adapter.storeRefreshToken(
      user.id,
      tokens.refreshToken,
      new Date(decoded.exp * 1000)
    );

    if (this.hooks.onLogin) await this.hooks.onLogin(user);

    console.log('[AuthManager] Login successful');

    return { user, ...tokens };
  }

  /**
   * Refreshes access and refresh tokens
   * @param {string} oldToken - The current refresh token
   * @returns {Promise&lt;Object>} Object containing new tokens {accessToken, refreshToken}
   * @throws {Error} If refresh token is invalid, expired, or reused
   */
  async refresh(oldToken) {
    if (!this.adapter) throw new Error('No database adapter configured');

    console.log('[AuthManager] Refresh token request');

    // Attempt to find the refresh token in storage
    const stored = await this.adapter.findRefreshToken(oldToken);

    let decoded;
    try {
      decoded = jwt.verify(oldToken, this.refreshSecret);
    } catch (err) {
      console.error('[AuthManager] Token verification failed:', err.message);
      if (stored) {
        await this.adapter.invalidateRefreshToken(oldToken);
      }
      throw new Error('Expired or invalid refresh token');
    }

    // If token not found in DB, treat as token reuse
    if (!stored) {
      console.log('[AuthManager] Token reuse detected, revoking all tokens');
      try {
        if (this.adapter.invalidateAllRefreshTokens) {
          await this.adapter.invalidateAllRefreshTokens(decoded.userId);
        }
      } catch (e) {
        if (this.hooks &amp;&amp; this.hooks.onError) await this.hooks.onError(e);
      }
      throw new Error('Refresh token revoked or not recognized (possible reuse)');
    }

    // Rotate token
    console.log('[AuthManager] Rotating refresh token');
    await this.adapter.invalidateRefreshToken(oldToken);
    const tokens = this.generateTokens({ userId: decoded.userId });
    const newDecoded = jwt.decode(tokens.refreshToken);
    await this.adapter.storeRefreshToken(
      decoded.userId,
      tokens.refreshToken,
      new Date(newDecoded.exp * 1000)
    );

    console.log('[AuthManager] Token refreshed successfully');
    return tokens;
  }

  verifyAccess(token) {
    return jwt.verify(token, this.secret);
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Mon Nov 10 2025 22:31:27 GMT+0300 (East Africa Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
